**Основы реактивности**

    Composition API - стал доступен с появлением 3-й версии. Лучше переиспользует логику, более гибко организовывает код. 
        <script setup>
            import { ref } from 'vue';
            const name = ref("World")
        </script>

    Options API
        <script>
            export default {
                data() {
                    return {
                        name: 'World'
                    }
                }
            }
        </script>

    Vue- реактивная библиотека. Это означает, что данные в компоненте отслеживаются и изменения автоматически отобразятся, если данные поменяем.

    Стандартно в js нет доступа отследить доступ к переменной при изменении значения, но мы можем перехватывать получение и установку св-в объекта с помощью методов
    геттеров и сеттеров.

    Установка таких значений происходит при оборачивании значения переменной в метод ref().

    const name = ref('John')
    name.value = 'ss'

    ".value" дает обнаружить, когда обращались к ссылке или когда она была изменена.
    "ref" может быть использован с любыми типами данных. Под капотом работает метод reactive.
    Для примитивов использовать ref, а для объектов и массивов использовать метод reactive, так как reactive с примитивами не работает.


**Синтаксис (интерполяция, bind-атрибутов)**

    Способы вывода переменных в html-размертку всего 2: интерполяция и привязка аттрибутов.

    Интерполяция - синтаксис двойных скобок {{name}}. Есть проблема: не работает в html-аттрибутах: <p class="{{name}}"></p>. Можно использовать тернарный оператор.

    Привязка через директиву- это специальные аттрибуты (с приставкой "v-"), которые добавляют реактивное поведение к DOM-элементов.

    v-bind. Сообщает вью поддерживать связь между аттрибутом html-разметки и переменной скрипта.

        <script setup>
            import { ref } from 'vue';
            let image = 'test';
        </script>

        <template>
            <img v-bind:src="image" alt="">
        </template>

        сокращенный вариант: <img :src="image" alt="">


**Вычисляемые свойства. Метод computed()**

    Если одно и то же выражение используется несколько раз, его следует вынести в вычисляемое свойство.
    Аналог функционального выражения в js. Преимущество computed- будет пересчитываться только при смене содержимого. Кеширует данные, помогая оптимизировать скорость страницы.
    Обычная же функция перессчитывается при каждом обращении.


**Вывод списков (директива v-for, списки объектов, ключи)**

    Директива v-for для вывода списка элементов. 


**Динамическое управление классами и стилями с помощью v-bind**

    Привязка нужна, когда в цсс-клас необходимо положить объект. Например, для определения класса:
    const isGreeting = ref(true);
    <p :class="{ greeting: isGreeting }"></p>
        или
         <p class="message" :class="{ 'greeting': isGreeting }"></p>


**Базовая обработка событий**

    Директива v-on для добавления слушателя событий.
    Сокращенный синтаксис - @*название метода* (@click). Автоматом имеет event.

    Модификаторы события:

        1. Всплытие события будет остановлено:
            <a @click.stop="doThis"></a>

        2. Событие перестанет перезагружать страницу:
            <a @click.prevent="doThis"></a>

        3. Обработчик будет вызван только раз:
            <a @click.once="doThis"></a>

        4. Объединение модификаторов в цепочки:
            <a @click.stop.prevent="doThis"></a>

        5. Использование без указания обработчиков:
            <a @click.stop.prevent></a>

        6. Вызов обработчика только в случае наступления события непосредственно на данном элементе:
            <div @click.self="doThat">...</div>


**Условный рендеринг (директивы v-if и v-show)**



**Передача данных в компонент (props)**

Есть два способа зарегистрировать компонент: локальный и глобальный.

Глобальный:
    1. Компонент всегда находится в <template>
    2. Импортируем глобально в main.js:
        import BaseButton from './components/BaseButton.vue'
    3. Добавляем к app:
        .component('BaseButton', BaseButton)

    Недостатки этого способа: мешает сборщикам удалять неиспользуемые компоненты. Если один компонент не вызывали вдругом, то он все равно попадет в итоговый бандл.
    Так же глобальная регистрация делает зависимость между компонентами менее очевидными в крупных приложениях. Из-за этого становится сложнее определить,
    откуда берется дочерний компонент, используемый в родителе. Это плохо сказывается на поддерже проекта в долгосрочной перспективе.

Локальный:
    Импорт в том компоненте, в котором будем использовать. Компонент будет доступен только в том месте, где был импортирован.

    Для передачи данных в компонент нужно определить входные параметры. Понадобится макрос defineProps:

        //Btn.vue
            <template>
                <button>{{ text }}</button>
            </template>

            <script setup>
                defineProps(['text'])
            </script>

        //App.vue
            <Btn text="Текст" />

    При передаче чего-либо дугого, отличного от текста в компонент, необходимо использовать v-bind:
            <Btn text="Текст" :number="2" />
    Можно добавлять любые типы данных.
    Сам макрос является объектом.

    Хорошей практикой является указание типа данных пропса:
        <script setup>
            const props = defineProps({
                text: {
                    type: String,
                    default: 'Значение по умолчанию',
                    required: true
                },
                number: Number
            })
        </script>


**defineEmits()**

    Используется для указания события, которое хотим отслеживать в компоненте:
        const events = defineEmits(['submit'])
        function buttonClick() {
            events('submit')
        }

    defineEmits так же, как и defineProps должен находиться на самом верхнем уровне. Нельзя определять внутри функции.

    Для emit следует использовать kebab-case


**Provide / Inject**

    Для передачи параметров по всей цепочки. 


**Слоты**

    Для вставки html-разметки во внутрь тега:
        //Btn.vue
            <button>
                <slot></slot>
            </button>
        
        //App.vue
            <BaseBtn>txt</BaseBtn>

    Можно вызывать в родителе, но внутри дочернего элемента содержимое неизвестно. Можно указывать значение по умолчанию.
         <slot>значение по умолчанию</slot>

    Имеет аттрибут name. Вызывается с помощью v-slot. Сокращенно #slotName.
    Чтобы управлять отображением слота, нужно добавить условие: "v-if="$slots.slotName"
    

**Единый источник истины и подъем состояния**

    Это два ключевых принципа, которые нужно помнить при подъеме состояния.

    Единый источник истины (Single Source of Truth, SSOT) - это концепция, которая утверждает, что данные в приложении должны храниться в одном месте, и это место должно быть доступно для всех частей приложения, которые нуждаются в этих данных.

    Подъем состояния (Lifting Tyaye Up) - концепция, при которой мы переносим состояние, которое должно быть доступно нескольким компонентам, в их общего родителя. Это подволяет всем дочерним компонентам взаимодействовать с этим состоянием через пропсы и события, а родительский компонент выятупает в качестве единого источника истины.


**Элементы формы — <input>, <textarea>**
    v-model будет автоматически определять свойства и события, которые будут отслеживаться, в зависимости от элемента, на котором он используется. 
    У элемента radio или checkbox понадобится свойство checked и событие change.
    У select - свойство value и событие change. 
    v-model игнорирует начальное значение аттрибута value, checked, select на любых элементах формы.

    const comment = ref("")
    <textarea v-model="comment"></textarea>


    const userName = ref('')
    <input v-model="userName" />


**Элементы формы — checkbox и radio**
    const radio = ref([])
    <input type="radio" id="q" v-model="radio" value="aa" />

**Элементы формы — <select>**
    Если значение селекта не указывается по дефолту, то это может привести к багу на IOS - пользователь не сможет выбрать первый вариант, потому что IOS не генерирует событие changed. Решение: всегда добавлять первым значением пустой value.


**Vue Select**

    Слабая стилизация - проблема селекта.


**Модификаторы v-model для оптимизации ввода**

    v-model.trim - перенос строки не попадет в итоговое значение
    v-model.lazy - данные пользователя попадают во вью только когда он уберет фокус с данного компонента
    v-model.number - автоматически старается преобраовать введенные данные в число


**Обработка отправки формы. Событие submit**

    Обработка происходит через обычную связку v-on (@submit)
    удобно создаватьобъект для отправки даннных целиком:

    const formData = reactive({
        userName: '',
        userLastName:''
    })

    <input type="text" v-model="formData.UserName"/>


**Template Refs**

    Vue старается абстрагироваться от прямых операций с DOM-деревом, все же это необходимо, например, когда форма состоит из нескольких шагов
    и, после того, как пользователь перешел на следующиий шаг, мы хотим установить фокус на первое поле ввода. И тогда неплохо иметь ссылку на это поле.
    
    Макрос defineExpose({}) - для явного объявления свойств в родителе из дочернего компонента

**Watchers (сравнение с computed)**
    Функция Watch- наблюдатель, помогает отслеживать изменения в переменной и выполнять действия, когда ее значение меняется.
    В кач-ве первого аргумента передаем переменную, которую хотим отслеживать, второй аргумент - метод обработчик, у которого первый аргумент - новое значение, вторым аргументом -старое значение.
    Первым аргументом могут быть различные типы реактивных источников (как ref, так и computed, объекты, функции и даже массивы). 
    Нужно помнить, что при вызове watch на объекте, обратный вызов будет возникать при любом изменении свойства объекта, насколько глубоко он бы ни лежал.
    В этом случае нельзя обратиться к конкретному свойству объекта, если передается не реактивный элемент.
    В качестве решения проблемы необходимо передать функцию, которая будет возвращать данное значение.

    Разница watch от computed заключается в том, что computed всегда возвращает какое-то значение, оно высчитывается на основе других реактивных данных, автоматически обновляется при изменении данных и вычисления происходят только по мере необходимости. Watch используем, когда нужно реагировать на изменение данных, выполняя какие-либо побочные эффекты. Полезно для ассинхронных операций, работы с сервером или любой другой логики, не связанной с вычисляемыми значениями.


**Как писать код, который поймёт команда**
    1. Хороший код должен быть понятен не только автору, но и команде.
    2. Не писать код только под себя.
    3. Читаемость кода
    4. Простота и предсказуемость кода
    5. Код читается чаще, чем пишется.

    Следовать основным принципам:
    KISS - Keep It Simple: простые решения лучше сложных
    YAGNI - You Arent gonna need it: важно понимание для чего необходим тот или иной функционал
    DRY - Dont Repeat Youself: не повторяйся. Дцблирование снижает производительность кода. Снижается его читабельность. Мы должны думать об уменьшении дубликатов.

    Имя переменной должно быть осмысленным, объяснять, зачем она нужна. Переменые должны быть связаны с бизнес-логикой.
    Каждая функция или компонент делает оно дело. Мелкие, независимые компоненты легче тестировать, переиспользовать и читать. Разделение на мелкие компоненты- не всегда хорошо - ререндеры сильно снижают производительность.
    Код строк должен быть самодокументированным. Данные должны храниться в переменных.
    Комментарий поясняет "почему", а не "что"


**Жизненный цикл компонента. Хуки onBeforeMount(), onMounted(), onBeforeUpdate(), onUpdated(), onBeforeUnmount(), onUnmounted()**
    Жизненный цикл начинается с фазы создания, когда компонент инициализируется. В этот момент происходит процесс подключения Composition API, затем Options API. Затем происходит фаза компиляции. Если шаблон готов, то переходим к рендерингу, если не готов - вью компилирует шаблон компонента в виртуальный DOM. Компонент считается смонтированным после вставки компонента. При измнении компонента, к-либо действий, происходит постоянный ре-рендеринг. 
    Размонтирование происходит если компонент удален со станицы. 

    OnBeforeMount - вызывается, когда компонент завершил настройку своего реактивного состояния, но ни один из узлов DOM-дерева еще не был создан.
    Хорошо использвать для установки к-либо глобальных настроек, получении данных с сервера или модификации состояния, которые влияют на начальную отрисовку компонента. Например, используется для проверки авторизации пользователя.

        onBeforeMounted(() => {

        })

    onMounted - срабатывает после появления элемента на странице. Компонент завершил первоначальную отрисовку и создал узлы в DOM. Пример использования: настройка внешних библиотек, обработчиков событий и взаимодействия элементов на странице. 

        onMounted(() => {

        })

    onBeforeUpdate - отрабатывает перед тем, как изменения появятся на странице. Например, когда нужно выполнить подготовку каких-либо данных перед тем, как показывать их пользователю. Для логирования изменения состояний.

        !! должен сначала отработать, а затем выполнить функцию, если вызвать на определенном компоненте. Но на 20 октября 2025 года функция вызывается одновременно с отработкой хука. Не касается дочернего компонента !!

        onBeforeUpdate(() =>{

        })

    onUpdated - во время обновления элемента

        onUpdated(() =>{

        })

    onBeforeUnmount() - перед удалением

        onBeforeUnmount(() =>{

        })

    onUnmounted() - комопнент полностью удален
     
        onUnmounted(() => {
            
        })

**Хук onErrorCaptured()**

    Хук служит для того, чтобы отлаливать ошибки, которые происходят в дочерних компонентах. Метод для логирования ошибок, для сохранения информации для дальнейшей отладки. Отлавливает ошибки только в дочерних компонентах.


**JSON Placeholder. Метод fetch()**