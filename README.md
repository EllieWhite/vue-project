**Основы реактивности**

    Composition API - стал доступен с появлением 3-й версии. Лучше переиспользует логику, более гибко организовывает код. 
        <script setup>
            import { ref } from 'vue';
            const name = ref("World")
        </script>

    Options API
        <script>
            export default {
                data() {
                    return {
                        name: 'World'
                    }
                }
            }
        </script>

    Vue- реактивная библиотека. Это означает, что данные в компоненте отслеживаются и изменения автоматически отобразятся, если данные поменяем.

    Стандартно в js нет доступа отследить доступ к переменной при изменении значения, но мы можем перехватывать получение и установку св-в объекта с помощью методов
    геттеров и сеттеров.

    Установка таких значений происходит при оборачивании значения переменной в метод ref().

    const name = ref('John')
    name.value = 'ss'

    ".value" дает обнаружить, когда обращались к ссылке или когда она была изменена.
    "ref" может быть использован с любыми типами данных. Под капотом работает метод reactive.
    Для примитивов использовать ref, а для объектов и массивов использовать метод reactive, так как reactive с примитивами не работает.


**Синтаксис (интерполяция, bind-атрибутов)**

    Способы вывода переменных в html-размертку всего 2: интерполяция и привязка аттрибутов.

    Интерполяция - синтаксис двойных скобок {{name}}. Есть проблема: не работает в html-аттрибутах: <p class="{{name}}"></p>. Можно использовать тернарный оператор.

    Привязка через директиву- это специальные аттрибуты (с приставкой "v-"), которые добавляют реактивное поведение к DOM-элементов.

    v-bind. Сообщает вью поддерживать связь между аттрибутом html-разметки и переменной скрипта.

        <script setup>
            import { ref } from 'vue';
            let image = 'test';
        </script>

        <template>
            <img v-bind:src="image" alt="">
        </template>

        сокращенный вариант: <img :src="image" alt="">


**Вычисляемые свойства. Метод computed()**

    Если одно и то же выражение используется несколько раз, его следует вынести в вычисляемое свойство.
    Аналог функционального выражения в js. Преимущество computed- будет пересчитываться только при смене содержимого. Кеширует данные, помогая оптимизировать скорость страницы.
    Обычная же функция перессчитывается при каждом обращении.


**Вывод списков (директива v-for, списки объектов, ключи)**

    Директива v-for для вывода списка элементов. 


**Динамическое управление классами и стилями с помощью v-bind**

    Привязка нужна, когда в цсс-клас необходимо положить объект. Например, для определения класса:
    const isGreeting = ref(true);
    <p :class="{ greeting: isGreeting }"></p>
        или
         <p class="message" :class="{ 'greeting': isGreeting }"></p>


**Базовая обработка событий**

    Директива v-on для добавления слушателя событий.
    Сокращенный синтаксис - @*название метода* (@click). Автоматом имеет event.

    Модификаторы события:

        1. Всплытие события будет остановлено:
            <a @click.stop="doThis"></a>

        2. Событие перестанет перезагружать страницу:
            <a @click.prevent="doThis"></a>

        3. Обработчик будет вызван только раз:
            <a @click.once="doThis"></a>

        4. Объединение модификаторов в цепочки:
            <a @click.stop.prevent="doThis"></a>

        5. Использование без указания обработчиков:
            <a @click.stop.prevent></a>

        6. Вызов обработчика только в случае наступления события непосредственно на данном элементе:
            <div @click.self="doThat">...</div>


**Условный рендеринг (директивы v-if и v-show)**



**Передача данных в компонент (props)**

    Есть два способа зарегистрировать компонент: локальный и глобальный.

    Глобальный:
        1. Компонент всегда находится в <template>
        2. Импортируем глобально в main.js:
            import BaseButton from './components/BaseButton.vue'
        3. Добавляем к app:
            .component('BaseButton', BaseButton)

        Недостатки этого способа: мешает сборщикам удалять неиспользуемые компоненты. Если один компонент не вызывали вдругом, то он все равно попадет в итоговый бандл.
        Так же глобальная регистрация делает зависимость между компонентами менее очевидными в крупных приложениях. Из-за этого становится сложнее определить,
        откуда берется дочерний компонент, используемый в родителе. Это плохо сказывается на поддерже проекта в долгосрочной перспективе.

    Локальный:
        Импорт в том компоненте, в котором будем использовать. Компонент будет доступен только в том месте, где был импортирован.

        Для передачи данных в компонент нужно определить входные параметры. Понадобится макрос defineProps:

            //Btn.vue
                <template>
                    <button>{{ text }}</button>
                </template>

                <script setup>
                    defineProps(['text'])
                </script>

            //App.vue
                <Btn text="Текст" />

        При передаче чего-либо дугого, отличного от текста в компонент, необходимо использовать v-bind:
                <Btn text="Текст" :number="2" />
        Можно добавлять любые типы данных.
        Сам макрос является объектом.

        Хорошей практикой является указание типа данных пропса:
            <script setup>
                const props = defineProps({
                    text: {
                        type: String,
                        default: 'Значение по умолчанию',
                        required: true
                    },
                    number: Number
                })
            </script>


**defineEmits()**

    Используется для указания события, которое хотим отслеживать в компоненте:
        const events = defineEmits(['submit'])
        function buttonClick() {
            events('submit')
        }

    defineEmits так же, как и defineProps должен находиться на самом верхнем уровне. Нельзя определять внутри функции.

    Для emit следует использовать kebab-case


**Provide / Inject**

    Для передачи параметров по всей цепочки. 


**Слоты**

    Для вставки html-разметки во внутрь тега:
        //Btn.vue
            <button>
                <slot></slot>
            </button>
        
        //App.vue
            <BaseBtn>txt</BaseBtn>

    Можно вызывать в родителе, но внутри дочернего элемента содержимое неизвестно. Можно указывать значение по умолчанию.
         <slot>значение по умолчанию</slot>

    Имеет аттрибут name. Вызывается с помощью v-slot. Сокращенно #slotName.
    Чтобы управлять отображением слота, нужно добавить условие: "v-if="$slots.slotName"
    

**Единый источник истины и подъем состояния**

    Это два ключевых принципа, которые нужно помнить при подъеме состояния.

    Единый источник истины (Single Source of Truth, SSOT) - это концепция, которая утверждает, что данные в приложении должны храниться в одном месте, и это место должно быть доступно для всех частей приложения, которые нуждаются в этих данных.

    Подъем состояния (Lifting Tyaye Up) - концепция, при которой мы переносим состояние, которое должно быть доступно нескольким компонентам, в их общего родителя. Это подволяет всем дочерним компонентам взаимодействовать с этим состоянием через пропсы и события, а родительский компонент выятупает в качестве единого источника истины.


**Элементы формы — <input>, <textarea>**
    v-model будет автоматически определять свойства и события, которые будут отслеживаться, в зависимости от элемента, на котором он используется. 
    У элемента radio или checkbox понадобится свойство checked и событие change.
    У select - свойство value и событие change. 
    v-model игнорирует начальное значение аттрибута value, checked, select на любых элементах формы.

    const comment = ref("")
    <textarea v-model="comment"></textarea>


    const userName = ref('')
    <input v-model="userName" />


**Элементы формы — checkbox и radio**
    const radio = ref([])
    <input type="radio" id="q" v-model="radio" value="aa" />

**Элементы формы — <select>**
    Если значение селекта не указывается по дефолту, то это может привести к багу на IOS - пользователь не сможет выбрать первый вариант, потому что IOS не генерирует событие changed. Решение: всегда добавлять первым значением пустой value.


**Vue Select**

    Слабая стилизация - проблема селекта.


**Модификаторы v-model для оптимизации ввода**

    v-model.trim - перенос строки не попадет в итоговое значение
    v-model.lazy - данные пользователя попадают во вью только когда он уберет фокус с данного компонента
    v-model.number - автоматически старается преобраовать введенные данные в число


**Обработка отправки формы. Событие submit**

    Обработка происходит через обычную связку v-on (@submit)
    удобно создаватьобъект для отправки даннных целиком:

    const formData = reactive({
        userName: '',
        userLastName:''
    })

    <input type="text" v-model="formData.UserName"/>


**Template Refs**

    Vue старается абстрагироваться от прямых операций с DOM-деревом, все же это необходимо, например, когда форма состоит из нескольких шагов
    и, после того, как пользователь перешел на следующиий шаг, мы хотим установить фокус на первое поле ввода. И тогда неплохо иметь ссылку на это поле.
    
    Макрос defineExpose({}) - для явного объявления свойств в родителе из дочернего компонента

**Watchers (сравнение с computed)**
    Функция Watch- наблюдатель, помогает отслеживать изменения в переменной и выполнять действия, когда ее значение меняется.
    В кач-ве первого аргумента передаем переменную, которую хотим отслеживать, второй аргумент - метод обработчик, у которого первый аргумент - новое значение, вторым аргументом -старое значение.
    Первым аргументом могут быть различные типы реактивных источников (как ref, так и computed, объекты, функции и даже массивы). 
    Нужно помнить, что при вызове watch на объекте, обратный вызов будет возникать при любом изменении свойства объекта, насколько глубоко он бы ни лежал.
    В этом случае нельзя обратиться к конкретному свойству объекта, если передается не реактивный элемент.
    В качестве решения проблемы необходимо передать функцию, которая будет возвращать данное значение.

    Разница watch от computed заключается в том, что computed всегда возвращает какое-то значение, оно высчитывается на основе других реактивных данных, автоматически обновляется при изменении данных и вычисления происходят только по мере необходимости. Watch используем, когда нужно реагировать на изменение данных, выполняя какие-либо побочные эффекты. Полезно для ассинхронных операций, работы с сервером или любой другой логики, не связанной с вычисляемыми значениями.


**Как писать код, который поймёт команда**
    1. Хороший код должен быть понятен не только автору, но и команде.
    2. Не писать код только под себя.
    3. Читаемость кода
    4. Простота и предсказуемость кода
    5. Код читается чаще, чем пишется.

    Следовать основным принципам:
    KISS - Keep It Simple: простые решения лучше сложных
    YAGNI - You Arent gonna need it: важно понимание для чего необходим тот или иной функционал
    DRY - Dont Repeat Youself: не повторяйся. Дцблирование снижает производительность кода. Снижается его читабельность. Мы должны думать об уменьшении дубликатов.

    Имя переменной должно быть осмысленным, объяснять, зачем она нужна. Переменые должны быть связаны с бизнес-логикой.
    Каждая функция или компонент делает оно дело. Мелкие, независимые компоненты легче тестировать, переиспользовать и читать. Разделение на мелкие компоненты- не всегда хорошо - ререндеры сильно снижают производительность.
    Код строк должен быть самодокументированным. Данные должны храниться в переменных.
    Комментарий поясняет "почему", а не "что"


**Жизненный цикл компонента. Хуки onBeforeMount(), onMounted(), onBeforeUpdate(), onUpdated(), onBeforeUnmount(), onUnmounted()**
    Жизненный цикл начинается с фазы создания, когда компонент инициализируется. В этот момент происходит процесс подключения Composition API, затем Options API. Затем происходит фаза компиляции. Если шаблон готов, то переходим к рендерингу, если не готов - вью компилирует шаблон компонента в виртуальный DOM. Компонент считается смонтированным после вставки компонента. При измнении компонента, к-либо действий, происходит постоянный ре-рендеринг. 
    Размонтирование происходит если компонент удален со станицы. 

    OnBeforeMount - вызывается, когда компонент завершил настройку своего реактивного состояния, но ни один из узлов DOM-дерева еще не был создан.
    Хорошо использвать для установки к-либо глобальных настроек, получении данных с сервера или модификации состояния, которые влияют на начальную отрисовку компонента. Например, используется для проверки авторизации пользователя.

        onBeforeMounted(() => {

        })

    onMounted - срабатывает после появления элемента на странице. Компонент завершил первоначальную отрисовку и создал узлы в DOM. Пример использования: настройка внешних библиотек, обработчиков событий и взаимодействия элементов на странице. 

        onMounted(() => {

        })

    onBeforeUpdate - отрабатывает перед тем, как изменения появятся на странице. Например, когда нужно выполнить подготовку каких-либо данных перед тем, как показывать их пользователю. Для логирования изменения состояний.

        !! должен сначала отработать, а затем выполнить функцию, если вызвать на определенном компоненте. Но на 20 октября 2025 года функция вызывается одновременно с отработкой хука. Не касается дочернего компонента !!

        onBeforeUpdate(() =>{

        })

    onUpdated - во время обновления элемента

        onUpdated(() =>{

        })

    onBeforeUnmount() - перед удалением

        onBeforeUnmount(() =>{

        })

    onUnmounted() - комопнент полностью удален
     
        onUnmounted(() => {
            
        })

**Хук onErrorCaptured()**

    Хук служит для того, чтобы отлаливать ошибки, которые происходят в дочерних компонентах. Метод для логирования ошибок, для сохранения информации для дальнейшей отладки. Отлавливает ошибки только в дочерних компонентах.


**JSON Placeholder. Метод fetch()**

    const posts = reactive([])
    const error = ref('')

    const fetchPosts = async () => {
        error.value = '';

        try {
        const response = await fetch('https://jsonplaceholder.typicode.com/posts');
        if (!response.ok) {
            throw new Error('errorerror')
        }
        const data = await response.json();
        posts.push(...data)
        } catch (err) {
        error.value = err.message;
        }
    }

    onMounted(() => {
        fetchPosts()
    })

    <template>
        <ul>
            <li v-for="post in posts" :key="post.id">{{ post.title }}</li>
            <div v-if="error">произошла ошибка {{ error }}</div>
        </ul>
    </template>

**HTTP-метод GET**

    GET запрашивает предоставление ресурса. Запросы с использованием этого метода могут только извлекать данные. 

**HTTP-метод DELETE**
**HTTP-метод POST**
**HTTP-метод PUT**

    PUT полностью заменяет существующий ресурс на сервере новыми данными, переданными в теле запроса. Если ресурс не существует, сервер может создать его (зависит от реализации API).

**HTTP-метод PATCH**

    PATCH используется для частичного обновления ресурса, изменяя только указанные поля, не затрагивая остальную часть данных.

**Повторное использование логики. Composable-функции**

    По соглашению, composable-функции всегда начинаются с приставки use и пишутся с помощью camelCase.
    В контексте приложений Vue "composable" функция — это функция, использующая Composition API Vue для инкапсуляции и повторного использования логики с отслеживанием состояния.


**Динамический useFetch()**

    утилита toValue Нормализует значения / ref-объекты / геттеры к значениям.


**Single Page Application**

    MPA работают по принципу- 1 страница - один url. Кажда перезагрузка может быть медленнее, ощущаться как дергание.
    SPA - при переходе между страницами нет полной перезагрузки. JS динамически обновляет необходимую часть интерфейса. Маршрутизатор отвечает за url-адреса.


**Vue Router**

    Компонент <RouterView/> представляет собой слот, который используется для отображения компонента маршрута. Под капотом выглядит след. образом:
    <RouterView v-slot='{ Component }'><component :is="Component" /></RouterView>

    Для создания перехода необходимо выполнить:
        1. элементы навигации поместить в тег <RouterLink to="/">Главное</RouterLink>
        2. Для <main> создать <RouterView />
        3. В main.js добавить 
            import router from './router';
            createApp(App).use(router).mount('#app')
        4. создать файл router.js
            import { createRouter, createWebHistory } from "vue-router";
            import HomeView from "./pages/HomeView.vue";
            import ContactsView from "./pages/ContactsView.vue";

            const routes = [
                { path: "/", component: HomeView },
                { path: "/contacts", component: ContactsView },
            ]

            export default createRouter ({
                history: createWebHistory(),
                routes
            })

    Для навигации-функции:
        import { useRouter } from 'vue-router';
        const router = useRouter();
        const onBtnClick = () => {
            router.push("/contacts")
        }

        <button @click="onBtnClick">перейти</button>

    Если мы не хотим хранить эту часть в сторе, а просто автоматически перезаписать текущую url, то вместо push использовать replace - он осущствляет навигацию без добавления новой записи в сторе, просто заменяет текущую. Помимо этого, replace так же будет работать как аттрибут в RouterLink.

    Метод go принимает в к-ве параметра целое число, которое указывает, на сколько щагов вперед или назад следует перейти в стеке истории

        router.go(1)


**Redirect. Страница 404**

    редирект:
        { path: "/c", redirect: "/contacts"},
    доп.адрес:
        { path: "/", component: HomeView, alias: "/home" },
    страница 404:
        { path: "/:pathMatch(.*)*", name: 'name', component: NotFound},


**Анимация и LazyLoading**

    <RouterView v-slot='{ Component }'><component :is="Component" />
        <Transition name="fade"></Transition>
    </RouterView>

    <style>
        .fade-enter-active,
        .fade-leave-active {
            transition: opacity .5s ease;
        }

        .fade-enter-from,
        .fade-leave-to {
            opacity: 0
        }
    </style>


**State managment**

    Организация бизнес-логики приложения в отдельном слое- Сторе. Это позволяет компонентам фокусироваться исключительно на отображении данных и взаимодействие с пользователем, когда вся логика и состояния приложения управляются отдельно.

    Таким образом, повышается переиспользоваемость кода, так как несколько компонентов могут использовать один стор для работы с состояниями. 
    За счет этого является отлично масштабируемым. 

    Простое хранилище может быть небезопасно - в какой-то момент тип данных в хранилище может измениться с числа нас строку. Во избежании этого, рекоммендуется описывать функции и методы внутри стора.


**Pinia**

    Название хранилища всегда начинается с приставки use (например, useCounter)

    Принято для каждого кейса создавать отдельное хранилище


**Пользовательские директивы**

    Вью позволяет использовать собственные пользовательские директивы. Их следует использовать только когда желаемая функциональность может быть достигнута только через прямое манипулирование DOM-деревом и элементами на странице. Представляет собой объект хуками жизненного цикла. Не стоит ими злоупотреблять.

        const myDirective = {
            // вызывается до применения атрибутов
            // связанного элемента или слушателей событий
            created(el, binding, vnode) {
            },
            // вызывается непосредственно перед вставкой элемента в DOM.
            beforeMount(el, binding, vnode) {},
            // вызывается, когда родительский компонент связанного
            // элемента и все его дочерние элементы смонтированы.
            mounted(el, binding, vnode) {},
            // вызывается перед обновлением родительского компонента
            beforeUpdate(el, binding, vnode, prevVnode) {},
            // вызывается после обновления родительского
            // компонента и всех его дочерних компонентов
            updated(el, binding, vnode, prevVnode) {},
            // вызывается перед размонтированием родительского компонента
            beforeUnmount(el, binding, vnode) {},
            // вызывается при размонтировании родительского компонента
            unmounted(el, binding, vnode) {}
        }

    const vMyDirective = {
        mounted(el) {
            el.classList.add('is-active')
        },
    }

    Директивы всегда начинаются с v, далее - название с camelCase

    <li v-mydirective>текст</li>

    Для указания глобальной директивы в main.js указываем метод directive(), где первый параметр - название директивы без приставки 'v' и camelCase, вторым - объект:
        create(App).directive(
            'highlight',
            {
                mounted(el) {
                    el.classList.add('is-highlight')
                }
            }
        ).mount('#app')


    Директива v-focus:
        const vFocus = {
            mounted(el) {
                el.focus()
            }
        }

    В HTML есть аттрибут autofocus. Преимущество директивы в том, что работает не только, когда страница загружается, но и когда элемент динамически вставляется с помощью Вью.

    
**Options API vs Composition API**

    Composition API НЕ ЯВЛЯЕТСЯ функциональным программированием.

    Преимущества Composition API:

        1. Лучшее переиспользование логики. Composition API обеспечивает чистое, эффективное повторное использование логики в виде Composable функции.
            Решает все недостатки миксинов - основного механизма повторного использования логики в Options API.

        2. Более гибкая организация кода. Options API накладывает серьезные ограничения, когда логика одного компонента перерастает определенный порог сложности.

        3. Лучшее выведение типов. Options API, изначально задуманный в 2013 году, был разработан без учета вывода типов. Composition API использует в основном простые переменные и функции, которые, естественно, дружественны к типам. Код, написанный в Composition API может использовать полный вывод типов с небольшой потребностью в ручных подсказках. Большую часть времени, код Composition API будет выглядеть практически одинаково в TypeScript и простом JavaScript. Это также позволяет обычным пользователям JavaScript извлекать выгоду из частичного вывода типов.

        4. Меньший размер production сборки и меньше накладных расходов. Код, написанный в Composition API и <script setup> также более эффективен и удобен для минификации, чем аналогичный в Options API. Это связано с тем, что шаблон в компоненте <script setup> скомпилирован как функция, встроенная в ту же область действия кода <script setup>. В отличие от доступа к свойствам через this, скомпилированный код шаблона может напрямую обращаться к переменным, объявленным внутри <script setup>, без промежуточного прокси экземпляра. Это также приводит к лучшей минимизации, поскольку все имена переменных можно безопасно сократить.


****